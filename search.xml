<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>企业级高并发短链接项目分享</title>
      <link href="/2025/02/15/%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE%E5%88%86%E4%BA%AB/"/>
      <url>/2025/02/15/%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>生产级别的互联网应用的架构、设计思路、原理及调优、演进思路。<br> 涉及到三高：高可用、高性能、高并发。<br> 广度和深度覆盖全面，能够全面体现出程序员的能力水平。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>电商推广：短信、邮件 一般来说，一条短信最多70个汉字，140个字节。如果超出一般会被运营商自动拆分为2条短信，增加了运营成本。<br> 社交网络分享：微博和Twitter都有140字数的限制，如果分享一个长链接，很容易就超出限制。短链接服务可以把一个长链接变成短链接，方便在社交网络上传播。</p><h2 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h2><p><img src="https://uploadfiles.nowcoder.com/images/20231117/5510556_1700187996129/B6C31D01D41C9E1714958F9C56D01D8F"></p><p>我们看到短信里面的URI是数字加子母组成的字符，跟我们平时写代码时的URI不太一样。<br>实际上这就是一个短链接，其实原始的内部长链接可能长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://dpubstatic.udache.com/static/dpubimg/d4c0e518e95afb4e669affa6eb15d1d6/index.html  </span><br></pre></td></tr></table></figure><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>用户点击这个短链接后，会跳转到内部的长链接。基本流程图:</p><p><img src="https://uploadfiles.nowcoder.com/images/20231117/5510556_1700188023732/7142B8354CA8A352B2B805F997C71549"></p><p>客户端–&gt;发出短链接请求–&gt; 重定向跳转—&gt;长链接</p><p> 为什么使用302重定向</p><p>重定向 时效性 请求方式 优点</p><table><thead><tr><th>301</th><th>永久</th><th>第一次会重定向，下次直接从浏览器缓存拿到长链接就可跳转</th><th>效率高</th></tr></thead><tbody><tr><td>302</td><td>临时</td><td>每次请求都会请求短链接服务器，浏览器不会缓存</td><td>方便统计入口链接的访问次数，短链接服务商主要盈利方式之一</td></tr></tbody></table><h2 id="软件详细设计"><a href="#软件详细设计" class="headerlink" title="软件详细设计"></a>软件详细设计</h2><h3 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h3><p>1.给定原始的Long URL，短链服务能生成比它短且唯一的Short URL<br>2.用户点击Short URL， 能跳转到Long URL<br>3.有效期&#x2F;过期机制<br>4.Short URL越短越好</p><h3 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h3><p>1.高可用：服务不能存在单点故障，用冗余来解决高可用问题。<br>2.高性能：生成Short URL以及从Short URL 跳转到Long URL 要近实时。读写比预估100:1<br>3.安全：短链不可被猜测(防止被攻击和滥用，引发不可知的情况)</p><h3 id="短链生成"><a href="#短链生成" class="headerlink" title="短链生成"></a>短链生成</h3><p>短链接的原理其实就是：将长链接通过一定的算法生成一个短链接。访问短链接时实际访问的是短链接服务器，然后根据短链接的参数找回对应的长链接重定向跳转。短URL包含一个短链接网站+短连接key。 系统本质上包含一个短链算法模块和一个Hash表。<br> 长URL通过短链算法生成短URL。将短URL作为key，长URL作为value，保存到Hash表中。<br> 用户输入短URL，直接从Hash表中查找并返回长URL。</p><h3 id="算法选择"><a href="#算法选择" class="headerlink" title="算法选择"></a>算法选择</h3><h4 id="算法要求"><a href="#算法要求" class="headerlink" title="算法要求"></a>算法要求</h4><ol><li>生成值比原始值短</li><li>唯一性</li><li>高效、低CPU内存消耗</li><li>安全不可预测</li></ol><h4 id="常见Hash算法"><a href="#常见Hash算法" class="headerlink" title="常见Hash算法"></a>常见Hash算法</h4><h5 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h5><p>准确说它是一种信息摘要算法，从一个字符串或一个文件中按照一定的规律生成一个特殊的字符串。<br> 生成的字符串是满足唯一性的，但输出是128位的，还是比较长</p><h5 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h5><p>SHA家族的五个算法，分别是SHA-1、SHA-224、SHA-256、SHA-384，和SHA-512，由美国国家安全局（NSA）所设计，并由美国国家标准与技术研究院（NIST）发布；是美国的政府标准。<br> 生成的字符串是满足唯一性的。输出长度还是较大，而且这类算法属于加密型HASH算法，本质是为了数据加密传输，后续需要能够逆向得到原始字符串，相应的算法性能比较低。<br> 评价一个哈希算法的好坏，人们通常会引用 SMHasher 测试集的运行结果。 Smhasher 测试Hash函数的功能，测试包括以下几个方面：</p><ul><li>Sanity 是不是可以使用的</li><li>Performance 完成一个散列需要多长时间</li><li>Differentials 产生相同哈希的概率，可能导致相同的的最小差异</li><li>Keysets 分布均匀程度<br> 一系列的测试方式具体可参考：<a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https://github.com/aappleby/smhasher/wiki/SMHasher">https://github.com/aappleby/smhasher/wiki/SMHasher</a></li></ul><h5 id="MurmurHash"><a href="#MurmurHash" class="headerlink" title="MurmurHash"></a>MurmurHash</h5><p>随机分布特征表现更良好，发生 Hash 碰撞的几率更低。比起 MD5它的性能至少提升了一个数量级。生成的结果为32bit或64bit相比MD5的长度缩短了一个量级。<br> MurmurHash在很多现代KV型存储中间件中被广泛使用，如在Redis中当字典被用作数据库的底层实现或者哈希键的底层实现时，Redis 使用 MurmurHash2 算法来计算键的哈希值。<br> 算法主页: <a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=http://code.google.com/p/smhasher/">http://code.google.com/p/smhasher/</a></p><h4 id="如何做到最短"><a href="#如何做到最短" class="headerlink" title="如何做到最短"></a>如何做到最短</h4><p>1000万用户平均每个月10条短信 每个月基本上1亿个短链接即可。 预估未来五年增长到5000万用户，5亿短链接基本够用。<br> 通常短链是用 [0-9], [a-z], [A-Z] 这 62 个字符的组合来表示的，我们可以选择用这62个字符对MurmurHash的结果做base62编码，那么长度是 N 的短链可以映射的 URL 数量如下图： <img src="https://uploadfiles.nowcoder.com/images/20231117/5510556_1700188072288/F15564B913BBBA5E94A8C204ED13BE58" alt="alt"><br> 5位长度基本满足未来五年需求，6位一定满足，按照6位来设计(扩展性更强，余地更多)。</p><h4 id="如何解决HASH冲突"><a href="#如何解决HASH冲突" class="headerlink" title="如何解决HASH冲突"></a>如何解决HASH冲突</h4><h5 id="冲突识别"><a href="#冲突识别" class="headerlink" title="冲突识别"></a>冲突识别</h5><p>方案1：先根据短链接查询数据库，如果不存在则插入；<br> 问题：先查再插入，涉及两次网络请求及可能的磁盘调度<br> 方案2：短链接字段建立唯一索引，直接插入，通过数据库唯一索引检测判断重复<br> 方案3：通过布隆过滤器快速判断短链不存在，不需要唯一索引，可消除磁盘IO调度影响<br> 但这个看似挺好，实际由于布隆过滤器数据易丢失，造成短链生成冲突</p><h5 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h5><p>尽管 MurmurHash 算法，冲突的概率非常低。但是，一旦冲突，就会导致两个原始链接被转化成同一个短链接。可以给原始链接拼接一串特殊字符，比如“[REPEAT]”，然后跟再重新计算哈希值，两次哈希计算都冲突的概率，显然是非常低的。</p><h4 id="如何解决重复长地址转换攻击"><a href="#如何解决重复长地址转换攻击" class="headerlink" title="如何解决重复长地址转换攻击"></a>如何解决重复长地址转换攻击</h4><p>用户连续发起对同样的长地址转换请求<br> 服务端处理逻辑：<br> 1）长地址 -&gt; 短地址<br> 2）短地址冲突<br> 3）长地址叠加随机值 -&gt; 短地址<br> 4）入库<br> 在大量请求下，一个长地址对应多个短地址，消耗数据库资源，并造成数据库操作效率降低。<br> 解决方案：<br> 1）给长地址也加唯一索引<br> 有没更高效的办法？<br> 2）使用布隆过滤器存储长地址，每次转换前先判断下长地址是否已经转换过。<br> 这种方法效率高，虽然有布隆过滤器数据丢失后造成长地址对应多个短地址，但在高可用Redis集群模式下，丢失的不会太多，对应多个短地址也不影响用户使用</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>采用计算速度快、冲突概率小的Murmur-Hash 算法，通过hash得到10进制数，然后转化成 62 进制表示法，进一步减小短链接的长度。对于哈希算法的哈希冲突问题，我们通过给原始网址添加特殊前缀字符，重新计算哈希值的方法来解决。</p><h3 id="短链接过期解决方案"><a href="#短链接过期解决方案" class="headerlink" title="短链接过期解决方案"></a>短链接过期解决方案</h3><p>短链接数据多为短时效存储数据，不需要永久保存，如优惠券、促销活动等，之前的设计中短地址是永久保存在数据库和分布式缓存中，会带来数据库和Redis的存储资源容量持续增长，最终导致访问数据库速度下降以及Redis的OOM问题。<br> 解决方案：设置过期时间，惰性删除 + 定时删除<br> 1、接口层面<br> 需要再重载一个接口，提供timeout字段可让用户自行决定保留时间，没有提供timeout可根据公司的业务场景给定一个默认保留时间<br> 2、Redis层面<br> 数据入Redis时设置过期时间，按照二八原则定律，百分之八十的数据会在存入数据后的百分之二十的过期时间内访问。<br> 1）为减少内存消耗，Redis中数据的过期时间为数据库中相应数据剩余保留时间的一定比例<br> 2）为避免缓存雪崩问题，保留比例设置为(0.2, 0.5)范围内的随机值。同时为避免Redis崩溃带来的雪崩问题，对Redis集群应做高可用处理<br> 3、数据库层面<br> 需加入createdTime，expiredTime两个数据类型为时间戳的字段， 参考Redis的数据过期处理原理 &#x3D;》惰性+定时删除相结合。<br> 1）数据库数据惰性删除<br> 查询数据时判断已过期，则同步删除，返回提示用户短地址已失效。 2）数据库数据定时删除<br> 通过定时任务，如每天凌晨扫描数据库中expiredTime &lt; now()的数据。 为<strong>避免锁表</strong>：读已提交隔离级别 + expiredTime设置索引。<br> 3）定时任务框架选择：<br> 1）JDK自带ScheduledExecutorService<br> 微服务多节点部署下重复执行的问题，不会出现业务问题，但浪费数据库性能<br> 2）分布式任务调度框架<br> 框架选型可参考：<a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https://cloud.tencent.com/developer/article/2046586">https://cloud.tencent.com/developer/article/2046586</a><br> 考虑到Saturn、ElasticJob需要额外依赖Zookeeper增加维护成本，XXL-JOB作为初学者部署及开发难度相对较大，<br> 数据库定时删除对于可用性和性能要求较低，这里选用Quartz作为调度框架</p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><h4 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h4><p><img src="https://uploadfiles.nowcoder.com/images/20231117/5510556_1700188099585/05266877D72B9576E8D907074DDDA274" alt="alt"></p><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>单表按照1800W数据来计算，3.6亿&#x2F;1800W &#x3D; 20张表。 单库按照8000W数据计算，3.6亿&#x2F;8000W &#x3D; 5个库。 url_mapping 分表的 key 可以使用短链 Key 或创建时间来计算 hash，通过一致性 Hash 算法把记录路由到对应的分表。<br> url_0url_mapping_0 ~ url_mapping_3<br> url_1url_mapping_4 ~ url_mapping_7<br> url_2url_mapping_8 ~ url_mapping_11<br> url_3url_mapping_12 ~ url_mapping_15<br> url_4url_mapping_16 ~ url_mapping_19</p><h3 id="性能极致优化"><a href="#性能极致优化" class="headerlink" title="性能极致优化"></a>性能极致优化</h3><h4 id="全局自增ID"><a href="#全局自增ID" class="headerlink" title="全局自增ID"></a>全局自增ID</h4><p>所谓的全局自增ID：我们的服务是集群模式，全局自增意味着此ID在该集群内唯一且自增。<br> <img src="https://uploadfiles.nowcoder.com/images/20231117/5510556_1700188157328/95106A90F455887E4A4B298735A4641B" alt="alt"><br> 去掉Hash的过程，同时预生成一批短链接，请求来了直接建立映射关系。<br> 不同于 Hash 算法，全局自增 ID 的方案不需要对长 URL 进行 Hash 转换。因为 ID 全局自增且唯一，能确保一个 ID 只映射一个长 URL，不存在Hash 算法中存在的多个长 URL 可能映射到同一个短链的问题。基于全局自增 ID 的方案，依赖自增ID产生的效率。<br> 可以选用无需即时生成的分布式ID解决方案，如美团的leaf开源组件，百度Uidgenerator开源组件，都有批量号段缓存及缓存预加载机制，ID的获取操作就是一个简单的数据GET操作，轻松可以达到十万级生成效率。<br> 缺点：生成的短链接是自增的，用户方可以猜测到业务的交易流水量，流水量对于很多互联网公司是机密敏感数据，会带来不安全性。可以考虑通过接口字段让用户自定义选择短链生成方式，同时短链服务本身也得做好功能可扩展性的设计。</p><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>一般的短链系统，基本都是读多写少，对于高频操作(读)，如果每次都从数据库取，开销较大，通常采用缓存技术来解决。 <img src="https://uploadfiles.nowcoder.com/images/20231117/5510556_1700188175510/560D4514BC25F890A38519E8A401BBF0" alt="alt"></p><h3 id="服务高可用设计"><a href="#服务高可用设计" class="headerlink" title="服务高可用设计"></a>服务高可用设计</h3><p>短链接服务是一个高并发项目，需保证高性能的同时，也要保证服务不间断。<br> 总体思路： Keepalive + Nginx + 多节点容器化部署 + Redis Sentinel + Mysql半同步</p><h4 id="负载均衡器选择"><a href="#负载均衡器选择" class="headerlink" title="负载均衡器选择"></a>负载均衡器选择</h4><h5 id="DNS轮询"><a href="#DNS轮询" class="headerlink" title="DNS轮询"></a>DNS轮询</h5><p>优点</p><ol><li>低成本：只需要在DNS服务器上把域名绑定多个A记录即可。域名注册商一般都免费提供此类解析服务。</li><li>部署简单：部署多个web应用实例，然后在DNS服务器上添加A记录。</li></ol><p>缺点</p><ol><li>可靠性低：业务机器出现问题，没有故障转移机制</li><li>负载分配问题：缓存绑定，负载不均衡</li></ol><h5 id="硬件负载"><a href="#硬件负载" class="headerlink" title="硬件负载"></a>硬件负载</h5><p>优点</p><ol><li>高性能：硬件负载均衡器可以处理大量的网络请求，具有很高的性能，可以满足高流量负载的需求。</li><li>高可靠性：硬件负载均衡器通常具有冗余的硬件和软件，可以提供高可靠性，防止单点故障导致整个系统崩溃。</li><li>高扩展性：硬件负载均衡器可以轻松地扩展和升级，以应对增加的网络负载。</li><li>安全性：硬件负载均衡器通常具有内置的安全特性，如DDoS攻击防御、SSL加速和安全连接等，可以保护网络安全。</li></ol><p>缺点</p><ol><li>成本高：硬件负载均衡器通常价格昂贵，需要更多的预算。</li><li>管理复杂：硬件负载均衡器的安装、配置和管理需要技术人员进行，需要较高的技术水平和时间投入。</li><li>灵活性差：硬件负载均衡器通常需要进行预配置，而且不太灵活，无法快速适应变化的网络环境。</li></ol><h5 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h5><p>LVS是Linux Virtual Server的缩写，是一个基于Linux内核的负载均衡器软件，旨在为高性能、高可用性和可扩展性的应用程序提供负载均衡和高可用性服务。<br> 优点</p><ol><li>LVS是一个内核级别的负载均衡器，运行时不存在用户态、内核态上下文切换的消耗，因此具有很高的性能和吞吐量。</li><li>LVS支持多种负载均衡算法和协议，可以根据实际需求进行配置。</li><li>LVS具有较好的可靠性和可扩展性，可以通过增加后端服务器来增加负载容量。</li></ol><p>缺点：</p><ol><li>LVS的安装和配置比较复杂，使用门槛较高，需要有一定的Linux系统和网络知识。</li><li>LVS的管理和维护成本比较高，需要专门的管理人员来进行操作和维护。</li></ol><ul><li>LVS的负载均衡器只能工作在内核空间中，不支持灵活的配置。</li></ul><h5 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h5><p>优点</p><ol><li>灵活性：Nginx支持多种负载均衡策略，可以根据请求的源IP地址、目标IP地址、源端口号、目标端口号等信息来判断请求的目标服务器，并将请求转发到合适的服务器上。</li><li>易于配置：Nginx的配置文件简单易懂，可以快速配置和部署，同时支持热部署，可以在不停止服务的情况下更新配置文件。</li><li>支持缓存。</li></ol><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>短链接服务预期QPS不会过万，Nginx作为负载均衡已经足够了</p><h4 id="负载均衡器高可用"><a href="#负载均衡器高可用" class="headerlink" title="负载均衡器高可用"></a>负载均衡器高可用</h4><p>Nginx作为负载均衡器，挂掉则服务整体不可用。这里选择用KeepAlive软件做Nginx高可用<br> <img src="https://uploadfiles.nowcoder.com/images/20231117/5510556_1700188195133/1E1B1BEE9AB8D94DACF75BD5E1703DBD" alt="alt"><br> 基本原理：通过建立主备两台服务器，保证一台服务挂了后另外一台还能提供服务。</p><h5 id="宕机检测"><a href="#宕机检测" class="headerlink" title="宕机检测"></a>宕机检测</h5><p>主节点和从节点维护心跳，从节点通过心跳检测主节点挂机，主节点挂机后，从节点升级为主节点</p><h5 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h5><p><img src="https://uploadfiles.nowcoder.com/images/20231117/5510556_1700188211539/124D35F05E29BF0152033BE62EF2D66D" alt="alt"><br> 从节点升级为主节点后，如何将用户访问转到新的主节点呢。用户访问的是短链接域名，通过DNS协议映射到负载均衡器节点。这里主备服务器会通过虚拟网卡技术生成同样的虚拟IP，DNS映射为该虚拟IP，那么理论上在IP协议层ARP协议会同时广播到这两台机器，但KeepAlive软件会只让主节点回复ARP包。这样当原主节点挂机后，用户访问的就是新的主节点。</p><h4 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h4><p>为避免单机Redis挂机导致缓存雪崩等问题，需建立Redis集群机制，常见的解决方案是搭建Redis Sentinel集群来做节点宕机检测及故障转移。这里注意不同的哨兵最好部署在不同的机房，进行隔离，以免没有足够的哨兵存活（&lt;quorun），无法进行故障转移。<br> <img src="https://uploadfiles.nowcoder.com/images/20231117/5510556_1700188224699/4D7CF33471A392D943F00167D1C86C10" alt="alt"></p><h4 id="数据库高可用"><a href="#数据库高可用" class="headerlink" title="数据库高可用"></a>数据库高可用</h4><p>常见的方案为建立主从集群，但注意数据库默认的复制为异步复制。主节点磁盘损坏，从节点未来得及复制时，数据会出现丢失。<br> <img src="https://uploadfiles.nowcoder.com/images/20231117/5510556_1700188267859/914FBB519FF1ACBAF602B2DCBD5184D6" alt="alt"> 可采取数据同步复制方案，主节点将数据同步到从节点，从节点返回数据重放成功后，主节点才返回用户成功。数据在主或从数据丢失后，用户是能实时感知的，可以通过选择重试来保证数据的可靠性。<br> 在企业级生产中，一般会采取同步加异步复制相结合的方案，简称半同步复制。主节点和同步复制的从节点会部署在同一地点的不同机房，异步复制的从节点部署在另外的机房，这样可以避免极低概率下同一地点的数据中心出现着火、网络中断等数据中断异常。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>科学上网</title>
      <link href="/2025/02/13/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
      <url>/2025/02/13/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步：开通套餐"><a href="#第一步：开通套餐" class="headerlink" title="第一步：开通套餐"></a>第一步：<a href="https://down.dginv.click/#/register?code=fpF169hK"><em>开通套餐</em></a></h2><h2 id="第二步：软件下载"><a href="#第二步：软件下载" class="headerlink" title="第二步：软件下载"></a>第二步：<a href="https://github.com/MetaCubeX/ClashMetaForAndroid/releases/download/v2.11.6/cmfa-2.11.6-meta-arm64-v8a-release.apk"><em>软件下载</em></a></h2><h2 id="第三步：导入节点"><a href="#第三步：导入节点" class="headerlink" title="第三步：导入节点"></a>第三步：导入节点</h2><p><img src="https://pic1.imgdb.cn/item/67aec278d0e0a243d4ff0c89.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些常用且免费的图床</title>
      <link href="/2025/02/13/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E4%B8%94%E5%85%8D%E8%B4%B9%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
      <url>/2025/02/13/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E4%B8%94%E5%85%8D%E8%B4%B9%E7%9A%84%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p>有条件还是推荐自己搭建一个，毕竟较隐私图片和一些二维码图等，自己搭不会容易挂。然后也算是因为博客文章等用免费的走过一些弯路，毕竟一定时间精力等因素限制范围内，免费的永远是最贵的！</p><p>免费的，还是推荐临时用或不重要图片资源。</p><p>免费tg图床推荐:</p><p>Telegraph-Image|免费图床，无需注册登录直接，请勿滥用。</p><p><a href="https://telegraph-image-92x.pages.dev/">Telegraph-Image</a></p><p>聚合图床是一个提供高速外链的免费图床，无限流量，无限外链，全球网络加速，提供API和客户端上传图片，专业的跨境电商图片上传和托管，适合亚马逊, wish, ebay, shopify, 速卖通等电商批量上传图片。</p><p><a href="https://www.superbed.cn/">聚合图床</a></p><p>16图床，永久免费，无需登录的图床<br><a href="https://111666.best/">https://111666.best/</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
